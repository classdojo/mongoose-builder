// Generated by CoffeeScript 1.6.2
(function() {
  var ModelInitializer, MongooseRelational, ObjectId, Schema, mongoose, _MongooseAdapter;

  mongoose = require("mongoose");

  Schema = mongoose.Schema;

  ObjectId = Schema.Types.ObjectId;

  _MongooseAdapter = require("" + __dirname + "/adapter");

  MongooseRelational = require("" + __dirname + "/../initializers.relational").plugin();

  /*
  Specific plugins
  */


  ModelInitializer = (function() {
    /*
      Method: constructor
    */
    function ModelInitializer(nodeBuilder, nodeManager, plugins) {
      this._nodeManager = nodeManager;
      this._nodeBuilder = nodeBuilder;
      this._plugins = plugins;
      this._models = {};
      this._rawSchemas = {};
      this._schemaTypes = {};
      this._childRelationships = {};
    }

    /*
      Method: prepSchemas
    
      Initializes mongoose schemas with mongoose specific
      schema format.
    */


    ModelInitializer.prototype.init = function(callback) {
      var _this = this;

      this._nodeBuilder.each(function(node) {
        _this._rawSchemas[node.name] = node.schema;
        node.setAlternateName(utils.pluralize(node.name));
        return _this._schemaTypes[utils.pluralize(node.name)] = node.type;
      });
      this._expandTypedPaths();
      this._schemas = this._initSchemas();
      return callback(null);
    };

    /*
      Method: addSchemaPlugins
    
      Determines each resource type and enriches
      it with the appropriate plugin.
    */


    ModelInitializer.prototype.addSchemaPlugins = function(callback) {
      var _this = this;

      this._nodeBuilder.each(function(n) {
        var collectionName, options, plugin, schema;

        collectionName = utils.pluralize(n.name);
        options = {
          thisSchemaName: n.name,
          thisCollectionName: utils.pluralize(n.name),
          models: _this._models,
          nodeManager: _this._nodeManager,
          short_name: n.short_name
        };
        plugin = _this._plugins[n.type];
        if (plugin != null) {
          console.log("Enriching schema " + n.name + " - " + n.type);
          schema = _this._schemas[n.name];
          return _MongooseAdapter.adapt(schema, options, plugin);
        } else {
          return console.error("Schema " + n.name + " of type " + n.type + " has no associated plugin.");
        }
      });
      return this._addRelationshipHooks(function(err) {
        return callback(err);
      });
    };

    /*
      Method: createModels
    
      Creates mongoose models from a set of passed in
      connection objects.  Connections are a hash with
      keys specifying the database type. For now there
      should only really be
    
        awardrecords:
          <conn object>
        default:
          <conn object>
    */


    ModelInitializer.prototype.createModels = function(connections, callback) {
      var db, modelName, _ref;

      _ref = this._schemas;
      for (modelName in _ref) {
        Schema = _ref[modelName];
        if (modelName === "AwardRecord") {
          db = connections['awardrecords'];
        } else {
          db = connections['default'];
        }
        this._models[modelName] = db.model(modelName, Schema);
      }
      return callback(null);
    };

    /*
      Method: get
    
      Returns model instances
    */


    ModelInitializer.prototype.__defineGetter__('models', function() {
      return this._models;
    });

    ModelInitializer.prototype.__defineGetter__('schemas', function() {
      return this._schemas;
    });

    /*
      private methods
    */


    /*
      Private Method: _expandTypedPaths
    
      Expands schema fields from embedded objects
        field1: {
          field2: "val"
        }
      into dot notation
    
      field1.field2 = "val"
    */


    ModelInitializer.prototype._expandTypedPaths = function(rawSchemas) {
      var field, fieldVal, schemaDefn, schemaName, typedSchema, _buildPath, _results,
        _this = this;

      _buildPath = function(field, fieldVal, typedSchema) {
        var nestedField, nestedKey, _results;

        if (_.isString(fieldVal)) {
          return typedSchema[field] = fieldVal;
        } else {
          _results = [];
          for (nestedKey in fieldVal) {
            nestedField = fieldVal[nestedKey];
            _results.push(_buildPath("" + field + "." + nestedKey, nestedField, typedSchema));
          }
          return _results;
        }
      };
      _results = [];
      for (schemaName in rawSchemas) {
        schemaDefn = rawSchemas[schemaName];
        typedSchema = schemaDefn.typed;
        _results.push((function() {
          var _results1;

          _results1 = [];
          for (field in typedSchema) {
            fieldVal = typedSchema[field];
            _results1.push(_buildPath(field, fieldVal, typedSchema));
          }
          return _results1;
        })());
      }
      return _results;
    };

    /*
      Private Method: _initSchemas
    
      Initializes mongoose schema objects adding
      indices and embedded documents.
    
      eg.
        Schema =
          typed:
            "field1": "String"
          indices:
            [{"field1": 1}]
          embed:
            "field2": ["SomeOtherSchema"]
    
      field1 is indexed and field2 is added as embedding
      SomeOtherSchema
    */


    ModelInitializer.prototype._initSchemas = function() {
      var schema, schemaName, schemas,
        _this = this;

      schemas = {};
      this._nodeBuilder.each(function(n) {
        var s;

        s = new Schema(n.schema.fields, {
          collection: utils.pluralize(n.name)
        });
        _this._addIndices(s, n.schema);
        return schemas[n.name] = s;
      });
      for (schemaName in schemas) {
        schema = schemas[schemaName];
        this._addEmbeddedFields(schemaName, schema, schemas);
      }
      return schemas;
    };

    /*
      Private Method: _addIndices
    
      Adds indices to a schema. Called by _initSchemas
    */


    ModelInitializer.prototype._addIndices = function(schema, rawSchema) {
      var index, _i, _len, _ref, _results;

      if (rawSchema.indices != null) {
        _ref = rawSchema.indices;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          index = _ref[_i];
          _results.push(schema.index.apply(schema, index));
        }
        return _results;
      }
    };

    /*
      Private Method: _addEmbeddedFields
    
      Adds embedded fields to schema.
    */


    ModelInitializer.prototype._addEmbeddedFields = function(schemaName, schemaToAdd, allSchemas) {
      var embeddedSchema, field, n, obj, rawSchema, sVal, _ref, _results;

      n = this._nodeBuilder.find(schemaName);
      if (n == null) {
        return console.error("Cannot find node for schema " + schemaName);
      } else {
        rawSchema = n.schema;
        if (rawSchema.embed != null) {
          _ref = rawSchema.embed;
          _results = [];
          for (field in _ref) {
            embeddedSchema = _ref[field];
            obj = {};
            if (_.isArray(embeddedSchema)) {
              sVal = [allSchemas[embeddedSchema[0]]];
            } else {
              sVal = allSchemas[embeddedSchema];
            }
            obj[field] = sVal;
            _results.push(schemaToAdd.add(obj));
          }
          return _results;
        }
      }
    };

    ModelInitializer.prototype._addRelationshipHooks = function(callback) {
      var mongooseRelational, permissionNode,
        _this = this;

      mongooseRelational = new MongooseRelational(this._schemas, this._models);
      permissionNode = this._nodeBuilder.find('Permission');
      if (permissionNode == null) {
        return callback(new Error("Permission node seems to be missing. Please ensure that you've defined a Permission schema"));
      } else {
        this._nodeBuilder.each(function(n) {
          var childName, childNode, children, opts, _i, _len, _results;

          if (n.children != null) {
            children = (n.children.many || []).concat(n.children.one || []);
            if (_.isEmpty(children)) {
              opts = {
                orphan: n.name
              };
              return mongooseRelational.addRelationship("orphan", opts);
            } else {
              _results = [];
              for (_i = 0, _len = children.length; _i < _len; _i++) {
                childName = children[_i];
                childNode = _this._nodeBuilder.find(childName);
                opts = {
                  parent: {
                    name: n.name
                  },
                  child: {
                    name: childNode.name
                  }
                };
                _results.push(mongooseRelational.addRelationship("parent_child", opts));
              }
              return _results;
            }
          }
        });
        return callback(null);
      }
    };

    return ModelInitializer;

  })();

  module.exports = ModelInitializer;

}).call(this);
