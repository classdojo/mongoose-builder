// Generated by CoffeeScript 1.6.2
/*
  A small mongoose adapter that transforms schemas from class-like coffeescript classes
  into the more idosyncratic mongoose plugin interface
*/


(function() {
  exports.adapt = function(schema, options, plugin) {
    var _plugin;

    _plugin = function(skema, options) {
      var configuration, fn, instanceMethodDefinition, instanceMethodName, m, pluginMethodDefinition, pluginMethodName, _ref, _ref1, _ref2, _ref3;

      configuration = options.nodeManager.find(options.thisCollectionName).configuration;
      _ref = plugin.prototype;
      for (pluginMethodName in _ref) {
        pluginMethodDefinition = _ref[pluginMethodName];
        if (pluginMethodName === 'constructor') {
          continue;
        }
        skema.methods[pluginMethodName] = configuration.methods.instance[pluginMethodName] || pluginMethodDefinition;
      }
      _ref1 = configuration.methods.instance;
      for (instanceMethodName in _ref1) {
        instanceMethodDefinition = _ref1[instanceMethodName];
        if (skema.methods[instanceMethodName] == null) {
          skema.methods[instanceMethodName] = instanceMethodDefinition;
        }
      }
      /*
        TODO(chris): Figure out a way to set these virtuals
        in a more intuitive place.  Perhaps take in a virtual
      
        Every model gets a _type_, _models_, and _configuration_ virtual.
        These methods use _ to prevent naming collisions with mongoose.
      
        _type_ is the collection name in mongo
      
        _models_ references initialized drivers and nodeManager
      */

      skema.virtual('_type_').get(function() {
        return options.thisCollectionName;
      });
      skema.statics._type_ = function() {
        return options.thisCollectionName;
      };
      if (options.short_name != null) {
        skema.virtual('_short_name_').get(function() {
          return options.short_name;
        });
      }
      skema.virtual('_models_').get(function() {
        var o;

        o = {
          drivers: options.models,
          nodeManager: options.nodeManager
        };
        return o;
      });
      skema.virtual('_configuration_').get(function() {
        return configuration;
      });
      if (configuration.virtuals != null) {
        _ref2 = configuration.virtuals.get;
        for (m in _ref2) {
          fn = _ref2[m];
          skema.virtual("" + m).get(fn);
        }
        _ref3 = configuration.virtuals.set;
        for (m in _ref3) {
          fn = _ref3[m];
          skema.virtual("" + m).set(fn);
        }
      }
      skema.methods.jsonify = function() {
        var attachedField, dbField, driverConf, newName, o, virtualFn, virtualName, _ref4;

        console.log;
        driverConf = this._configuration_.driver;
        o = {};
        for (dbField in driverConf.schema.fields) {
          if (driverConf.schema.clientMappings != null) {
            if ((newName = driverConf.schema.clientMappings["" + dbField]) != null) {
              o["" + newName] = this["" + dbField];
            } else {
              o["" + dbField] = this["" + dbField];
            }
          } else {
            o["" + dbField] = this["" + dbField];
          }
        }
        if (driverConf.schema.virtualFields != null) {
          _ref4 = driverConf.schema.virtualFields;
          for (virtualName in _ref4) {
            virtualFn = _ref4[virtualName];
            o["" + virtualName] = virtualFn();
          }
        }
        if (this._configuration_.attach != null) {
          for (attachedField in this._configuration_.attach) {
            if (this._doc["" + attachedField] != null) {
              o["" + attachedField] = this._doc["" + attachedField];
            }
          }
        }
        return o;
      };
      return skema.methods.attach = function(name, clbk) {
        var _this = this;

        if ((this._configuration_.attach == null) || (this._configuration_.attach["" + name] == null)) {
          return clbk(new Error("No attachment with name " + name), null);
        } else {
          return this._configuration_.attach["" + name](this, function(err, val) {
            if (err != null) {
              return clbk(err, null);
            } else {
              _this._doc["" + name] = val;
              return clbk(null, _this);
            }
          });
        }
      };
    };
    return schema.plugin(_plugin, options);
  };

}).call(this);
